코딩 자율학습 HTML+CSS+JavaScript

8.1 자바스크립트 코드 작성 방법

8.1.1 HTML 파일과 자바스크립트 연결하기
    내부 스크립트, 외부 스크립트 2가지
    ● 내부 스크립트방법 : 내부 스크립트는 HTML 파일에서 script 태그의 콘텐츠 영역에서 자바스크립트 코드를 작성하는 방법
        <body>
            <script>
                document.write("내부 스크립트 방법");
            </script>
        </body>
    ● 외부 스크립트 방법 : js 확장자로 된 별도의 파일을 생성하고 생성한 파일에 자바 스크립트 코드를 작성한뒤 , HTML과 연결하는 방법
        <body>
          <script src="script.js"></script>
        </body>
    ● script 태그 사용위치
      script 태그는 항상 body 태그의 종료 태그 바로 전에 사용. 이는 내부 외부 모두 동일

8.1.2 자바스크립트 코드 실행하기
    document.write() : 웹브라우저에 텍스트를 표시해 주는 코드
    console.log() : 에디터에서 실행할때

8.2 프로그래밍 시작 전 알아두기

8.2.1 주석
    한줄만 주석일때 : //
    여러줄 주석: /* */

8.2.2 자바스크립트 오류 확인 방법
    컴파일 방식과 인터프리터 방식이 있다
    컴파일 방식: 코드를 실행하기 전에 모든 코드를 컴퓨터가 이해할 수 있는 기계어로 한번 변환한 후 실행
    인터프리터 방식 : 코드를 한번에 한줄씩 실행하는 방식
    자바스크립트는 인터프리터 방식 : 오류가 발생한 시점과 줄번호를 알려주고 오류 발생시점부터 실행을 멈춘다.
    자바스크립트에서 오류가 발생하면 크롬의 개발자 도구에서 확인 가능

----------------------------------------------------------------------------------------------------------------------------
마무리
1. 자바스크립트 코드 작성 방법
    1) 자바 스크립트를 웹 브라우저에 적용하는 방법은 크게 2가지
        내부스크립트 방법 : HTML문서안에서 script 태그의 콘텐츠 영역에 자바 스크립트 코드를 작성하는 방법
        외부스크립트 방법 : 별도의 js확장자 파일을 만들어 자바스크립트 코드를 작성하고 이 파일을 HTML 문서에서 script태그로 연결하는 방법
        script 태그의 사용 위치 : script 태그는 웹 브라우저에 화면이 표시되는 것에 영향을 미치지 않도록 body 태그가 끝나기 전에 사용
    2) 자바 스크립트를 단순히 실행할 목적이라면 웹브라우저의 개발자 도구에서 지원하는 콘솔창 활용하기, VSCode의 Code Runner 확장 프로그램 활용하기

2. 주석
    1) 한줄주석은 //
    2) 여러줄 주석은 /* */

3. 오류 확인 방법
    자바스크립트는 코드가 한번에 한줄씩 실행되는 인터프리터 기반의 언어.
    그래서 오류가 발생하면 그 즉시 실행을 멈추고 오류가 발생한 줄 번호를 웹브라우저의 콘솔창에 출력
    따라서 모든 오류 관련 메세지는 웹브라우저의 콘솔창에서 확인 할 수 있음. (~329)　　
----------------------------------------------------------------------------------------------------------------------------

9.1 변수와 상수
    데이터를 저장하는 공간을 변수와 상수라고 한다

9.1.1 변수
    변수는 변하는 수

         식별자     표현식<-값(30)
    var   num   =   10 + 20 ;
    키워드      연산자

    ● 키워드
      어떤 역할이나 기능이 정해진 특별한 단어. 다른말로는 '예약어' 라고도 한다.
    ● 식별자
      내부에서 변수, 함수 등에 부여되는 이름을 의미, 키워드는 식별자로 사용할 수 없음
    ● 연산자
      이름 그대로 어떠한 연산작업을 하는데 사용하는 기호
      = 기호는 우변에 있는 데이터를 좌변에 할당하는 역할을 하기 때문에 할당연산자라고 한다
    ● 표현식
      평가(표현식을 실행해 하나의 값을 만드는 과정)되어 하나의 값을 반환하는 식 또는 코드
    ● 값
      더 이상 평가 할수 없는 데이터
    ● 세미콜론
      하나의 문법이 끝났음을 의미
    ● 선언, 할당, 초기화
      변수를 생성하고 값을 저장하는 문법에서 var 키워드나 let, const 키워드를 사용해 변수의 식별자를 지정하는
      행위를 '변수를 선언한다' 라고한다.
      그리고 할당 연산자인 = 기호로 우변에 있는 값을 변수 공간에 대입(저장)하는 것을 '값을 할당한다' 라고 한다.
      변수는 초기에 값을 할당하지 않고 선언만 할 수 있다
      ex) var num;
      또 선언과 할당을 한번에 하면 '변수를 초기화한다'고 한다
      var num = 10 + 20 ; //변수 num을 초기화한다

9.1.2 새로운 변수 선언 키워드 let
    let num = 10 + 20;

    var와 let의 차이
    1. 변수명 중복이 불가능하다
       var는 중복해서 생성가능
             var num = 10 + 20;
             var num = 50;
       이렇게 하면 기존에 할당된 10+20이라는 데이터가 사라지고 50이라는 새로운 값이 할당된다
       let의 경우 밑에 처럼하면 에러난다.
             let num = 10+20;
             let num = 50;

    2. 호이스팅되지 않는다
       호이스팅은 var 키워드로 변수를 선언하고 할당했을 때, 변수 선언을 자바스크립트의 스코프 맨위로 올려 실행하는 것을 말한다
             console.log(num)
             var num = 10;
             결과 : undefinded
         오류가 발생해야 맞지만 오류가 아니라 undefined를 출력한다 이유는?
             var num; // 선언이 최상위로 올라옴
             console.log(num)
             num = 10; // 할당은 원래 자리에 있음
         호이스팅에 의해 선언부가 최상위로 올라간다 그러나 let에서는 호이스팅이 일어나지 않는다
         같은 코드를 작성하고 실행하면 num변수가 정의되지 않았다는 오류가 발생한다.

9.1.3 상수
    변수를 선언할 때 사용하는 키워드로 const도 있다
    기본은 let과 같다
    다른점은 const는 재할당이 안된다는 것이다

    상수는 보통 변하지 않는수를 의미 const는 재할당이 안되는 특징때문에 상수변수를 선언할때 사용하는 키워드라고 하기도한다.
    예를들어 다음과 같이 let키워드는 변수를 선언하고 다른값으로 재할당 할 수 있다
        let num = 0;
        num = 30;
        console.log(num);
        //실행결과 30

    그러나 const 키워드는 재할당할 수 없어서 오류가 발생한다.
        const num = 10;
        num = 30;
        console.log(num);
    TypeError: Assignment to constant variable.

    재할당이 안되기 때문에 선언을 먼저하고 할당을 나중에 하는 것도 안된다.
        const num; // 선언을 먼저 하고
        num = 10; // 할당을 나중에 해도 오류가 난다.
    SyntaxError: Missing initializer in const declaration

9.1.4 식별자 명명 규칙
    표기법                   설명                      예
    카멜표기법        변수명과 함수명 작성시 사용      firstName,lastName
    언더스코어표기법    상수명 작성 시 사용           FIRST_NAME, last_name
    파스칼표기법       생성자 함수명 작성 시 사용     FirstName, LastName

9.2 자료형
    기본자료형과 참조자료형으로 구별
    기본자료형 : 문자, 숫자, 논리, undefined, null, symbol
    참조자료형 : 객체

9.2.1 문자열
    큰 따옴표나 작은따옴표로 둘러싸인 값의 형태
        let string1 = 'Hello, World';
        let string2 = "Hello, World";
    문자열 데이터를 정의할때 큰따옴표로 시작했으면 큰따옴표로 끝나야 하고 작은 따옴표로 시작했으면 작은따옴표로 끝나야한다.

        ● 문자열에 따옴표가 포함된 경우
            작성하려는 문자열에 퐇마되지 않은 따옴표로 문자열을 감싸서 정의
            문자에 작은 따옴표가 포함되어있다면 큰따옴표로 감싸고 큰따옴표가 포함되어있다면 작은따옴표로 감싼다.
                let string1 = '문자열은 큰따옴표(")로 감싸면 된다'
                let string2 = "문자열은 큰따옴표(')로 감싸면 된다";
            그러나 문자열에 작은 따옴표가 둘다 포함되어 있다면 이걸로 해결되지 않는다.
            그럴때 문자열 연결연산자(+) 또는 이스케이프 문자로 해결

        ● 문자열 연결 연산자
            let string = ' 문자열 ' + " 연결 연산자 "; // 문자열 연결 연산자
            let string = '문자열은 큰따옴표(")나' + "작은따옴표(')로 감싸면 된다."; // 잇문자열은 큰따옴표(")나작은따옴표(')로 감싸면 된다.

         ● 이스케이프 문자
            웹브라우저는 문자열에 들어있는 큰따옴표나 작은따옴표에 역슬래시를 붙이면 일반적인 따옴표로 인식한다.
            let string = '문자열은 큰따옴표(")나 작은따옴표(\')로 감싸면 된다';
            // 문자열은 큰따옴표(")나 작은따옴표(')로 감싸면 된다

            이스케이프 문자          설명
            \'                  작은따옴표
            \"                  큰따옴표
            \n                  줄바꿈
            \t                  수평 탭
            \\                  역슬래시

            let string = "이스케이프 문자를 이용해서\n줄 바꿈하고 싶어";
            // 이스케이프 문자를 이용해서
               줄 바꿈하고 싶어

         ● 템플릿 문자열
            백틱(``) : 1옆에 있는거 영어일때만 나옴
            기준 문자열 정의 방식처럼 큰 따옴표나 작은 따옴표로 문자열을 정의하지 않기 때문에 문자열에 큰따옴표나 작은 따옴표가 있어도 영향을 받지 않는다.
            템플릿 문자열의 특징
             1. enter를 눌렀을때 줄바꿈이 적용된다. 그래서 이스케이프 문자안써도 된다
                    let string = `문자열은 큰따옴표(")나
                    작은따옴표(')로 감싸면 된다`
                    // 문자열은 큰따옴표(")나
                       작은따옴표(')로 감싸면 된다
             2. ${} 문법을 이용해 문자열에 변수 또는 식을 넣을 수 있다.
                외부에 미리 정의한 변수 또는 표현식을 넣어 연산한 값을 변수에 할당
                    let dan = 3;
                    let gugu = 8;
                    let string = `${dan} 곱하기 ${gugu}은 ${dan * gugu}입니다.`;
                    // 3 곱하기 8은 24입니다.

9.2.2 숫자형
    정수와 실수를 구분하지않고 하나의 자료형으로 취급
        let num1 = 10;
        let num2 = 0.1;
        // 10
           0.1
    그러나 실수를 사용할 때는 주의해야함 실수를 부동 소수점 방식으로 표현하면 실수 계산이 정확하지 않다.
        let sum = 0.1 + 0.2;
        // 0.30000000000000004

9.2.3 논리형
    true, false
        let boolean1 = 10 < 20;
        let boolean2 = 10 > 20;
        // true
           false

9.2.4 undefined
    변수나 상수를 메모리 공간에 선언하면 반드시 생성한 공간에 저장할 데이터를 할당해야한다.
    할당하지 않을경우 자바스크립트 내부적으로 변수와 상수공간에 임시로 데이터를 할당하는데, 이때 할당되는값이 undefined
    사용자가 임의로 정의하고 할당하는 자료형이 아니다.
        let empty;
        console.log(empty); // undefined

9.2.5 null
    null자료형은 null값하나만 있다. 변수나 상수를 선언하고 의도적으로 선언한 공간을 비워 둘때 할당한다.
        let empty = null;
        console.log(empty); //null

9.2.6 객체
    배열, 객체 리터럴, 함수가 있다.
        ● 배열
            배열로 정의한 데이터를 '요소'라고 한다.
            그리고 배열 요소에 접근하려면 '인덱스'를 사용한다.
                let studentScore = [80, 70, 90,60]; // 국어, 영어, 수학, 과학 점수
                console.log(studentScore[1]); //70, 1번 인덱스의 데이터에 접근
            배열은 모든 자료형을 저장할 수 있다.

        ● 객체 리터럴
            객체를 정의하는 가장 간단한 방법. 중괄호를 사용.
            중괄호 안에는 키(key)와 값(value)의 한쌍으로 이루어진 속성(property)이 들어간다
                {
                         속성
               키 →    key1:value1  ← 값
               키 →   ,key2:value2  ← 값
                         속성
                }
            값을 키로 구분한다는 장점이 있다.
            키가 있기때문에 각 값의 의미를 바로 파악할 수 있다.
                let studentScore = {
                    koreanScore: 80
                    , englishScore: 70
                    , mathScore: 90
                    , scienceScore: 60
                };
                console.log(studentScore.koreanScore);     //80
                console.log(studentScore['englishScore']); //70

9.3 연산자
    이항산술연산자(+,-,*,/,%,**)
        ** : x ** y x와 y의 거듭제곱을 구한다.
    단항부정
        - : -x x의 부호를 보정한다(음수면 양수로 양수면 음수로)

9.3.3 비교 연산자
    연산자         예               설명
    ==         x == y    x와 y의 값이 같으면 true를 반환
    ===        x === y   x와 y의 자료형이 같으면 true를 반환
    !==        x !== y   x와 y의 값과 자료형이 다르면 true를 반환

9.3.4 논리 연산자
    연산자         예               설명
     !           !x    x가 참이면 false를 반환하고 거짓이면 true를 반환한다

9.3.7 형 변환
    데이터의 자료형이 다른 자료형으로 바뀌는 것
    암시적 형변환과 명시적 형변환이 있다.

        ● 암시적형변환
            const result = 10 + "10";
            console.log(result); //1010
          자바스크립트가 내부적으로 숫자형 데이터를 문자열 데이터로 형 변환했기 때문
          암시적 형 변환은 사용자가 의도하지 않았지만 자바스크립트에서 자체적으로 형변환 하는 것
          은근 많이씀
            let num = 10;
            let strNum = "10";
            if(num == strNum){ //문자열을 숫자형으로 형 변환
                console.log('equals');
            } //equals

        ● 명시적 형변환
            드러나게 형변환을 처리하는 것
            예를 들어 다음처럼 String()메서드를 사용하면 문자열을 숫자형으로 명시적 형 변환을 할 수 있다.
                let num = 10;
                let strNum = "10";
                if (String(num) == strNum){
                    console.log('equals'); //equals
                }

9.5.6 for...in
    형식
        for(가변수 in 배열/객체 리터럴){
        // 블록문
        }
    for문안의 소괄호 안에 in키워드를 두고 키워드의 오른쪽에는 탐색의 대상이 되는 배열 또는 객체리터럴
    왼쪽에는 배열 또는 객체리터럴을 탐색해서 키를 저장할 가변수(임시변수)를 놓는다.

    ● 객체리터럴을 반복할 경우
        let obj = {name:"철수", age:"20"};
        for (let key in obj){
            console.log(key + ": ", obj[key]);
        }
      for in 문으로 객체 리터럴을 반복 탐색하면 탐색 결과로 가변수에 객체 리터럴의 키가 할당되어 객체 리터럴의 키와 값을 출력할 수 있다.

    ● 배열을 반복할 경우
        let arr = ["orange","apple","banana"];
        for (let index in arr){
            console.log(index +": " + arr[index]);
        }
        // 0: orange
        // 1: apple
        // 2: banana
-----------------------------------------------------------------------------------------------------------------------
마무리
    1. 변수와 상수 변수
        자바스크립트에서 데이터를 저장할 수 있는 공간을 변수와 상수 변수라고 한다.
        변수는 변할 수 있는 데이터를 저장하는 공간,
        상수변수는 재할당할 수 없는 데이터를 저장하는 공간
    2. 자료형
        기본자료형
            문자열: 큰따옴표나 작은따옴표로 둘러싸인 값
            숫자형: 정수, 실수를 포함한 모든 숫자
            논리형: 논리값 (true, false)
            undefined: 변수에 아무런 값도 할당되지 않는 상태를 나타내는 값
            null: 변수를 의도적으로 비워두기 위해 사용하는 값
        참조자료형
            객체: 배열, 함수, 객체리터럴 등으로 파생되는 상위자료형
    3. 연산자
        + - * / % ** ++ -- = += -= == != 등등
    4. 연산자 우선순위
        필요하면 인터넷 검색
    5. 조건문
        if, switch
    6. 반복문
        while, do...while, for, for...in
    7. break, continue
        반복문을 종료할때 break, 건너뛰게 할때는 continue
-----------------------------------------------------------------------------------------------------------------------

10.1 함수란?
    어떤목적을 가지고 작성한 코드를 모아 둔 블록문이다.
    코드를 함수로 만들면 함수를 호출해 함수내부에 모아 둔 여러줄의 코드를 한번에 실행할 수 있다.
    그래서 여러곳에서 재사용하기가 편하다.
    3단을 반복문으로 만들면
        for (let i = 0; i<=9; i++){
            console.log(`3 * ${i} = ${3*i}`);
        }
    반복문으로 작성하면 3줄이된다.
    이걸 만약 여러곳에서 쓴다면?
    이 상태에서 3단이 아니라 9단을 출력해야하는 상황이 생긴다면?
    일일히 수정해야 하기때문에 어려워짐
    이럴때 함수로 묶으면 편리하다
        function gugudan(){ // 함수시작
            for (let i = 0; i<=9; i++){
                console.log(`3 * ${i} = ${3*i}`);
            }
        } //함수 끝
    블록문을 function 키워드 식별자 소괄호와 함께 묶으면 함수가 생성되는데 이를 함수를 정의한다. 라고 한다
    이렇게 함수를 정의하면 함수를 호출시키기만 하면된다.

10.2 함수를 정의하면 방법
    함수선언문, 함수표현식, 화살표함수 등을 사용해 정의한다.

10.2.1 함수 선언문으로 함수 정의하기
    형식
        function 식별자 () {}
    {}중괄호에는 함수가 호출되면 실행할 코드를 적어준다.
    코드는 길이, 갯수의 제한이 없다
    나중에 함수명(); 으로 실행 가능

10.2.2 함수표현식으로 함수 정의하기
    함수도 변수에 할당할 수 있다.
    함수에 식별자가 있으면 '네이밍함수' 없으면 '익명함수' 로 구별한다.
    형식
        const 변수명 = function(){}; // 익명함수
        const 변수명 = function 식별자 (){}; // 네이밍함수

        함수선언문으로 정의한 gugudan() 함수를 함수표현식으로 바꾸면 이렇게 한다.
            네이밍함수
                const gugudan = function gugudan(){
                    for (let i = 0; i<=9; i++){
                        console.log(`3 * ${i} = ${3*i}`);
                    }
                };
                gugudan(); // 함수호출

        단, 함수 선언문과는 다르게 function 키워드 다음에 오는 식별자로 함수를 호출하지 않고, 할당한 변수명으로 호출
        그래서 다음처럼 function 키워드 다음에 식별자가 없는 익명 함수도 함수를 호출하는데 문제가 없다.
            익명함수
                const gugudan = function (){
                    for (let i = 0; i<=9; i++){
                        console.log(`3 * ${i} = ${3*i}`);
                    }
                };
                gugudan(); // 함수호출 문제없음

        만약 function 키워드 다음에 오는 함수 식별자로 호출하면 어떻게 될까?
                const gugudan = function naming (){
                    for (let i = 0; i<=9; i++){
                        console.log(`3 * ${i} = ${3*i}`);
                    }
                };
                naming(); // 호출안됨 naming is not defined

        naming 변수가 정의되지 않았다는 참조 오류가 남. 따라서 함수표현식으로 함수를 정의할때는
        function 키워드 다음에 오는 식별자가 아니라 변수명으로 호출해야 한다.

        함수표현식으로 함수를 정의할때는 const 키워드를 주로 사용한다. let, var로 해도 되지만
        const로 하는것이 좋다. 왜냐하면
        보통 함수는 일관된 목적을 가진 코드의 집합이라서 재정의해서도, 재할당해서도 안되는 경우가 많기 때문이다.
        (함수표현식으로 함수를 정의할때는 네이밍함수로 하는 것이 좋다. 또한 네이밍함수의 식별자를 변수명과 똑같이 만들면
         이름을 번생각하지 않아도 되고 호출할때도 헷갈리지 않아서 좋다.)

10.3 함수 기능 확장하기

10.3.1 매개변수와 인수
    매개변수(parameter) 인수(argument)
        매개변수 : 함수를 정의할때 외부에서 전달하는 데이터를 함수에서 받을 수 있도록 정의하는 변수
        인수 : 정의한 함수를 호출할때 소괄호 안에 전달하고 싶은 데이터를 적는것
    매개변수는 제한없이 여러개를 만들 수 있고 여러개일때는 쉼표로 구분해 나열하면 된다. 함수를 호출할때는 인수 또한 매개변수의 갯수에 맞춰 작성

    형식
    // 함수 선언문
        function 함수명(매개변수1, 매개변수2, ..., 매개변수N) {};
    // 함수 표현식
        const 함수명 = function 식별자(매개변수1, 매개변수2, ..., 매개변수N){};
    // 화살표 함수
        const 함수명 = (매개변수1, 매개변수2, ..., 매개변수N) => {};
    // 함수 호출
        함수명(인수1, 인수2, ..., 인수N);

    //코드
        // 화살표 함수
        //dan = 매개변수
        const gugudan1st = (dan) => {
          for (let i=1; i <= 9; i++){
              console.log(`${dan} * ${i} = ${dan * i}`);
          }
        }

        // 함수 선언문
        function gugudan2nd(dan){
            for (let i = 1; i <= 9; i++){
                console.log(`${dan} * ${i} = ${dan * i}`);
            }
        }

        // ()안에 3,6,9가 인수
        gugudan1st(3); // 3단 출력
        gugudan2nd(6); // 6단 출력
        gugudan2nd(9); // 9단 출력

    이렇게 매개변수와 인수를 사용하면 함수를 확장해서 좀더 폭넓게 사용할 수 있다.

10.3.2 매개변수의 특징

    ● 데이터 전달
        일대일 대응한다. 첫번째 인수는 첫번째 매개변수에 할당되고 두번째 인수는 두번째 매개변수에 할당된다.
                 숫자 10 전달   숫자 20 전달
        function sum(num1,      num2){}
        sum(10, 20);

      매개변수는 변수의 특징을 그대로 가지고 있다.
      변수를 선언하고 값을 할당하지 않으면 undefined값으로 초기화되는것처럼 매개변수도 함수호출시 데이터를 전달하지 않으면 undefined값이 할당된다.
        function sum( num1,          num2){}
        sum(10, 20);  ↑ undefined  ↑ undefined

      함수를 호출할때 데이터를 전달하지만 매개변수가 정의되지않은경우에는 아래처럼된다.
          function sum(){}       매개변수가 없어도 오류는 안난다
          sum(10, 20);           단 전달한 데이터를 받을 변수가 없어서 값을 전달해도 사용 x

      화살표 함수 매개변수 정의
        const sum = (num1, num2) => {
            console.log(num1, num2);
        };
        sum(10,20);
      단 화살표함수는 매개변수가 1개일 경우는 () 생략이 가능하다
        const sum = num1 => {
            console.log(num1);
        };
        sum(10);

    ● 기본값 할당
        기본값을 지정하는 방식이 있다.
        매개변수에 직접 데이터를 할당하는 방식으로 단순하게 기본값을 지정할 수 있다
            function sum (a = 10, b = 10){
                console.log(a,b);
            }
            sum(); // 10, 10

    ● return 문
        함수를 호출할 때 데이터를 전달하려면 매개변수를 정의해야 하듯이 함수 외부로 데이터를 반환할때는 return문을 사용해야 한다.
            형식
                return 식(또는 값)

            내부에서 result 변수를 참조해 값을 출력하는 코드
                function sum(num1, num2){
                    let result = num1 + num2;
                    console.log("inner: " +result);
                }
                sum(10,20); // 30

            이 코드를 바꾸면 오류가 발생한다
                function sum(num1, num2){
                     let result = num1 + num2;
                }
                sum(10,20);
                console.log("out:  " +result); // ReferenceError: result is not defined
            정의되지 않는 변수 오류.
            함수 외부에서 내부의 변수를 참조하려고 해서 발생한 오류

            오류가 나지 않게 하려면 return문으로 함수 내부데이터를 함수 외부로 전달해야 한다.
                 function sum(num1, num2){
                     let result = num1 + num2;
                     return result;
                 }
                 const result = sum(10,20);
                 console.log("out: " +result); //out: 30

            sum 함수의 내부변수인 result가 return 문에 작성되어 있다.
            이렇게하면 함수내부 변수인 result에 할당한 값, 즉 데이터가 sum() 함수를 호출한 곳으로 전달된다.
            이를 '반환한다' 라고 하며 이때 반환된 데이터를 '반환값' 이라고 한다.
            이렇게 반환된 데이터를 함수 외부에서 사용하려면 함수 호출 부분에서 반환값을 다시 변수에 할당해야 한다.
            만약 호출 부분에서 변수에 할당하지 않으면 반환값을 사용할 수 없으므로 return 문 사용할 필요없다.

            데이터를 반환할때 return 문에 꼭 변수를 써야하는건아니고 표현식으로도 데이터 반환 가능하다
                function sum(num1, num2){
                    return num1 + num2; // return문에 꼭 변수가 없어도 표현식으로도 데이터 반환가능
                }
                const result = sum(10,20);
                console.log("out: "+result); //out: 30

            return문은 데이터를 반환하지않으면 단순하게 함수 실행을 종료하는 역할만 한다.
            함수 내부에서 데이터를 반환하지 않는 return 문을 만나면 return 문 다음에 코드가 있어도 함수실행을 즉시 종료하고 undefined를 반환한다.

            화살표함수와 return 문
                화살표 함수에서 {}을 생략하면 화살표 다음에 오는 코드는 return문으로 처리된다
                예를들어 다음코드는 매개변수 num1, num2의 합을 즉시 반환한다.
                    const sum = (num1, num2) => num1 + num2;
                    const result = sum(10, 20); // 30
                    console.log(result);

10.4　함수의 특징 이해하기

10.4.1 스코프
    함수 내부의 변수를 함수 외부에서 참조할 수 없는 이유는?
    이를 이해하려면 스코프 개념을 알아야한다.
    스코프 : 변수나 함수와 같은 참조 대상 식별자를 찾아내기 위한 규칙
    함수스코프냐 블록스코프냐에 따라 전역스코프,지역스코프의 참조범위가 달라진다.

    ● 함수 스코프
        함수 스코프는 함수에서 정의한 블록문만 스코프의 유효범위로 인정하는 방식
        결국 함수 내부는 지역스코프, 함수 외부는 전역 스코프 영역이 된다.
        코드를 보면 함수 외부에 변수 a를 선언하고 선언한 변수를 함수 내부와 외부에서 각각 참조한다
            //코드
            let a = 10; // 전역스코프
            function sum(){
                console.log(`함수 내부: ${a}`);
            }
            sum();
            console.log(`함수 외부: ${a}`);
            // 함수외부: 10
            // 함수외부: 10
        함수내외부에서 문제없이 변수a를 참조해 출력한다.
        이는 함수외부는 전역스코프이고 전역스코프는 스코프와 상관없이 모두 참조할 수 있기 때문

        이와 반대로 밑에 코드에서 함수 내부에 선언한 변수 a는 지역스코프이다.
        따라서 함수 내부가 아닌 외부에서 변수a를 참조하려고 하면 오류가 발생한다.
            //코드
            function sum2(){
                let b = 10; // 지역스코프
                console.log(`함수내부: ${b}`); // 함수 내부: 10
            }
            sum();
            console.log(`함수외부: ${b}`) // ReferenceError: b is not defined

    ● 블록 스코프
        블록 스코프는 {}로 구성된 블록문 기준으로 스코프의 유효범위를 나누는 방식
        단, 이 방식은 let과 const 키워드로 선언한 변수에 한해서만 적용된다.
        코드를 보면 블록 스코프 외부에 let 키워드로 변수 a를 선언하고
        블록 스코프 내부에 let 키워드로 변수 b를 선언한 뒤 블록 스코프 내부와 외부에서 각각 참조한다.
            //코드
            let a = 10;
            {
                let b =20;
                console.log(`코드 블록 내부 a : ${a}`); // 코드 블록 내부 a : 10
                console.log(`코드 블록 내부 b: ${b}`); // 코드 블록 내부 b: 20
            }
            console.log(`코드 블록 외부 a : ${a}`); // 코드 블록 외부 a : 10
            console.log(`코드 블록 외부 b : ${b}`); // ReferenceError: b is not defined

        코드를 실행하면 변수 a는 전역 스코프여서 블록문 내부나 외부에서 전부 참조할 수 있다.
        그러나 변수 b는 블록문 내부에 선언한 지역 스코프여서 블록문 내부에서 참조에 문제가 없지만
        외부에서는 참조 오류가 발생하는 것을 확인할 수 있습니다.

        블록스코프는 오직 let, const 키워드에서만 발생하므로 같은 코드를 var키워드로만 바꿔 실행하면 참조오류가 발생하지 않는다.
        var 키워드는 함수 스코프 방식으로만 스코프를 나누기 때문에 다음 코드에서는 변수 a, b 모두 전역 스코프에서 선언한 것과 마찬가지이다.
            //코드
            var a = 10;
            {
                var b = 20;
                console.log(`코드 블록 내부 a : ${a}`); // 코드 블록 내부 a : 10
                console.log(`코드 블록 내부 b : ${b}`); //코드 블록 내부 b : 20
            }
            console.log(`코드 블록 외부 a : ${a}`); // 코드 블록 외부 a : 10
            console.log(`코드 블록 외부 b : ${b}`); // 코드 블록 외부 b : 20

    ● 참조 우선순위
        let, const 키워드는 같은 식별자의 중복 선언이 불가능하다.
        정확하게는 같은 스코프 영역에서 중복 선언이 불가능하다
        다음 코드를 보면 let, const 키워드로 변수 a,b를 함수 외부에 선언하고 함수내부에도 똑같이 a,b를 선언했는데 오류가 발생하지 않는다.
        //코드
        let a = 10;
        const b = 20;
        function sum(){
            let a = 50;
            const b = 70;
            console.log(`함수 내부 a: ${a}`); // 함수 내부 a: 50
            console.log(`함수 내부 b: ${b}`); // 함수 내부 b: 70
        }
        sum();
        전역 스코프와 지역 스코프에 같은 식별자를 가지는 참조 대상이 있다면 먼저 같은 지역 스코프의 식별자를 참조한다.
        그리고 같은 지역 스코프에서 참조할 식별자를 찾지 못할 때만 전역 스코프에서 찾는다.

10.4.2 함수 호이스팅
    호이스팅은 코드를 선언과 할당으로 분리해 선언부를 자신의 스코프 최상위로 끌어올리는 것을 말한다.
        // 코드
        console.log(num);
        var num = 10;
    이 코드에서 오류가 발생할 것 같지만 호이스팅에 의해 다음 코드처럼 작동한다
        //코드
        var num; // 선언부를 스코프 최상위로 끌어올림
        console.log(num); // undefined 출력
        num = 10;
    선언부를 최상위로 끌어올리기 때문에 결과로 undefined가 출력된다.
    이런 호이스팅은 var 키워드로 선언한 변수에만 적용되고 let과 const에는 적용되지 않는다.
    그런데 함수도 호이스팅된다.
        //코드
        printHello();
        function printHello(){
            console.log("Hello");
        }
    함수가 정의되기 전에 호출하고 있어서 오류가 나거나 정상적으로 실행되지 않을 것 같지만 코드를 실행해보면 함수가 정상적으로 호출되어
    Hello라는 값이 출력된다.
    함수선언문으로 정의된 함수는 호이스팅에서 선언부로 본다.
    그래서 앞의 코드는 코드 실행 시 함수 선언문을 최상위로 끌어올리면서 다음 코드처럼 실행된다.
        //코드
        function printHello(){ //함수 선언문을 최상위로 끌어올림
            console.log("Hello");
        }
        printHello();
    그러나 함수 표현식으로 정의된 함수는 함수 선언문으로 정의된 함수와는 조금 다르게 작동한다.
        //코드
        printHello();
        var printHello = function printHello(){
            console.log("Hello");
        }
        //TypeError: printHello is not a function
    함수 표현식에서 선언부는 변수를 선언한 부분이다. 그래서 실제로는 다음과 같이 실행되어 'printHello는 함수가 아니다'라는 오류메세지가 나오게 된다
        //코드
        var printHello;
        printHello();
        printHello = function printHello(){
            console.log("Hello");
        }
        화살표 함수 방식으로 정의해도 결국 함수표현식처럼 변수에 할당하는 것이므로 함수 표현식과 같은원리로 호이스팅된다.
        단 함수 표현식이나 화살표 함수를 let이나 const 키워드로 선언했다면 호이스팅 자체가 되지 않는다.

24.11.10(일)
10.5 즉시 실행 함수 사용하기
    즉시실행함수 : 함수를 정의하면서 동시에 실행까지 하는 함수
    형식 : (function(){})();
    일반적으로 함수를 선언하면 전역스코프에 정으된다. 그리고 프로그램이 종료되기 전까지 전역스코프에 선언한 함수는 메모리에서 사라지지 않는다.
    다음 코드를 보면 함수표현식으로 정의된 init() 함수가 있다. const 키워드에 할당했기 때문에 프로그램이 종료되기 전까지는 init 식별자를
    재사용할 수 없다
        const init = function(){
            console.log("initialized!");
        }
    그런데 이 함수는 어차피 한번만 쓸건데 const 키워드 때문에 init 식별자를 더이상 사용할 수 없게 된다.
    이러한 현삭을 가르켜 '전역 스코프가 오염됐다' 라고 표현한다.
    이런경우 즉시 실행 함수로 함수를 정의 하면 전역 스코프가 오염되는 걸 방지할 수 있다.
    즉시 실행 함수는 한번 실행되고 나면 메모리에 데이터가 남아 있지 않는다.
    그래서 init 식별자는 한 번도 사용되지 않은 것처럼 인식된다. 실제로 즉시 실행 함수를 호출한 다음에 재호출하면 참조오류가 나며 실행되지 않는다.
        //코드
        (function init(){
            console.log("initialized");
        })(); // initialized

        init(); // ReferenceError: init is not defined
    매개 변수가 있는 함수도 즉시 실행 함수로 정의 해서 실행할 수 있다. 코드를 다음과 같이 작성하면 된다
        //코드
        (function sum(a,b){
            console.log(a + b);
        })(10,20); //30

-----------------------------------------------------------------------------------------------------------------------
마무리
    1. 함수
        함수는 어떤 목적을 가지고 작성한 코드를 모아둔 블록문
    2. 함수 정의
        함수를 정의하는 방법은 크게 3가지이다.
            형식
            // 함수 선언문
            function 함수명(){}

            // 함수 표현식
            const 함수명 = function() {}; // 익명함수
            const 함수명 = function 식별자 () {}; // 네이밍함수

            //화살표 함수
            const 함수명 = () => {};

    3. 매개변수
        매개변수는 함수가 호출될 때 전달받은 데이터를 할당하기 위해 함수에서 선언하는 변수로, 다음과 같은 특징이 있다.
            ●　매개변수의 기본값은 undefined 다
            ●　함수를 호출하며 데이터를 전달해도 매개변수를 정의하지 않으면 데이터를 전달받지 못한다,. 단 오류가 생기지는 않는다.
            ●　함수를 호출할 때 전달한 데이터와 매개변수는 일대일 매칭관계가 형성된다.

    4. return 문
        return 문을 사용하면 함수내부에서 함수를 호출한 곳으로 데이터를 전달할 수 있다.

    5. 스코프
        1) 스코프는 변수나 함수와 같은 참조 대상 식별자를 찾아내기 위한 규칙
        2) 스코프는 블록 스코프 방식과 함수 스코프 방식을 기준으로 전역 스코프와 지역 스코프로 구분한다.

    6. 함수 호이스팅
        호이스팅은 코드를 선언과 할당으로 나누었을 때 선언부를 스코프 최상위로 끌어올리는 것을 말한다.
        함수 선언문이나 var 키워드를 사용한 함수 표현식, 화살표 함수 방식은 전부 호이스팅의 대상이된다.

    7. 즉시 실행 함수
        즉시 실행 함수는 함수를 정의하면서 동시에 실행까지 하는 함수다
            (function() {} ) ();
-----------------------------------------------------------------------------------------------------------------------

11장 자바스크립트 객체 다루기
    11.1 객체란?
        키(key)와 값(value)으로 구성된 속성의 집합
        객체는 {} 를 이용해 생성할 수 있는데 이런 방법을 '리터럴' 방식으로 객체를 생성했다고 표현한다.
        그리고 다음 코드 처럼 속성이 한 개도 없는 객체를 '빈객체' 라고 한다
            const person = {};
        보통 객체를 생성할 때는 빈 객체로 생성하지 않고 처음부터 속성을 지정한 상태로 생성한다.
        만약 사람에 대한 객체를 생성한다면 다음과 같은 속성을 지정해 객체를 생성할 수 있다.
            const person = {name:"Junhyung"};
        속성은 객체의 의미에 나와 있듯이 키와 값으로 구성된다.
        name이 키고 Junhyung이 값이다. 객체는 이런 속성을 여러개 가질 수 있다.

        객체는 데이터의 종류를 가리지 않는다. 모든 자료형의 데이터를 값으로 가진다
        배열, 숫자, 논리 데이터를 다음과 같이 한 객체의 속성으로 추가 할 수 있다.
            const person = {
                name:["Park","Junhyung"]
                , age: 35
                , isAdult: true
            };
        객체 안에 또다른 객체나 함수가 들어갈 수도 있다.
            const person = {
                name:{
                    firstName:"Junhyung"
                    ,lastName:"Park"
                }
                , age: 35
                , isAdult: true
                , printInfo: function(){
                    console.log('printInfo');
                }
            };
        보통 객체의 키는 문자열로 작성하는데 큰따옴표나 작은따옴표로 표시하지않아도 문제되지 않는다.
        다만 키에 공백이 들어갈 경우에는 따옴표를 꼭 사용해야한다.

        ⭐️함수와 메서드
            객체에서 속성의 값으로 함수가 들어갈 때는 보통 함수라고 하지않고 메서드라고 한다.
            함수라고 하기도 하지만 메서드를 더 일반적으로 사용한다.

11.2 객체 속성 다루기

11.2.1 객체 속성에 접근하기
    배열에서 데이터에 접근할 때 인덱스를 사용했는데
    대괄호 연산자와 마침표 연산자를 사용한 두가지 접근방법이 있다.

    ●　대괄호 연산자로 접근하기
        대괄호 연산자는 []를 사용해 객체의 속성에 접근하는 방법으로 배열에서도 사용할 수 있다.
        객체의 속성에 접근하려면 객체명 뒤에 대괄호를 붙이고 대괄호 안에 키를 넣는다.
        이때 키는 반드시 큰 따옴표나 작은 따옴표로 감싼 문자열 형태로 작성해야한다.
            // 코드
            const person = {
                name: "Junhyung"
                , age: 35
            };
            console.log(person["name"]);
            console.log(person["age"]);

            //코드
            const person = {
                name:{
                    firstName: "Junhyung"
                    , lastName: "Park"
                },
                likes:["apple","banana"]
                , printHello:function (){
                    return "hello";
                }
            };
            접근방법
                console.log(person["name"]) // { firstName: 'Junhyung', lastName: 'Park' }

                //person 객체의 name 속성에 값으로 할당된 객체의 firstName 속성에 접근
                console.log(person["name"]["firstName"]); //Junhyung

                객체의 속성값이 배열이나, 객체 리터럴, 함수라면 어떻게 접근하나?
                // 배열
                console.log(person["likes"]); //[ 'apple', 'banana' ]
                console.log(person["likes"][0]); //apple
                console.log(person["likes"][1]); //banana

                //함수
                console.log(person["printHello"]); //[Function: printHello]
                함수를 호출할 때는 ()를 사용하므로 결국 person 객체의 printHello() 함수에는 다음처럼 접근한다.
                console.log(person["printHello"]()); //hello

     ●　마침표 연산자
        마침표 연산자는 .을 이용해 객체 속성에 접근한다.
            //코드
            console.log(person.name.firstName); //Junhyung
            console.log(person.age); //35
            console.log(person.likes[0]); //apple
            console.log(person.printHello()); //hello

        객체의 키 식별자에 공백이 있다면 마침표 연산자는 사용할 수 없고 대괄호 연산자로만 접근할 수 있다. 」　24.11.10(일)

24.11.11(월)

11.2.2 객체 속성 값 변경하기
    객체로 정의된 값을 바꾸고 싶다면 키로 속성에 접근해서 값을 재할당하면 된다.
    다음 코드는 변수 person에 할당된 객체의 속성에 키로 접근해 값을 변경한다.
        //코드
        const person = {
            name:"Junhyung Park"
        };
        person.name = "Kim"; // 또는 person["name"] = "Kim";
        console.log(person.name); //Kim

11.2.3 객체 속성 동적으로 추가하기
    객체 속성에 키로 접근해 값을 재할당하면 기존 속성값을 변경할 수 있다.
    그런데 해당 키가 객체에 없다면 즉 객체에 없는 속성이라면 해당 키와 값으로 구성된 새로운 속성이 객체에 추가된다.
    예를들어 먼저 객체 리터럴 방식으로 빈 객체를 생성하고 변수에 할당한다.
    그리고 객체의 속성에 접근해 값을 변경할 때처럼 키에 값을 할당한다.
    person 객체를 출력해보면 처음엔 빈 객체였는데 나중에 name 속성이 추가 된 것을 볼 수 있다.
    이처럼 객체 속성에 값을 할당해 접근하면 해당 속성이 존재하는지 확인하고, 없는 속성이면 해당 키와 값으로 구성된 새로운 속성을 객체에 추가한다.
        //코드
        const person = {};
        console.log(person); // {}
        person.name = "Junhyung Park";
        console.log(person); // { name: 'Junhyung Park' }

    정리하면 객체 식별자와 키에 마침표 연산자를 사용하면 객체의 속성에 접근하게 되고
    속성에 접근하여 할당 연산자로 값을 할당하면 값이 변경되거나 새로운 속성이 추가된다.

    객체 속성의 값이 함수나 배열 객체 리터럴일 때도 같은 방법으로 값을 변경하거나 새로운 속성을 추가할 수 있다.
        //코드
        const person = {};
        person.name = {
            firstName:"Junhyung"
            , lastName:"Park"
        };
        person.likes = ["apple","samsung"];
        person.printHello = function (){
            return "hello";
        }
    이렇게 이미 만들어진 객체에 나중에 속성을 추가하는 것을 '속성을 동적으로 추가한다' 고 한다

11.2.4 객체 속성 동적으로 삭제하기
    객체 속성에 접근할 때 앞에 delete 키워드를 명시하면 해당 속성이 삭제된다.
    다음처럼 delete 키워드로 person 객체의 하나뿐인 name 속성을 삭제하고 person 객체를 출력해보면 빈 객체가 출력된다.
        //코드
        const person = {
            name : "Junhyung Park"
        };
        delete person.name; // 또는 delete person["name"]
        console.log(person); // {} 출력 」　24.11.11(월)

24.11.15 (금)
11.2.5 객체의 데이터 관리 방법 이해하기
    const 키워드로 선언한 상수 변수는 원래 재할당이 불가능하지만 객체에 속성을 추가하거나 삭제할 수 있었다.
    이유는 객체 참조형의 특성인 '참조(reference)' 때문에 그렇다
    자료형을 기본 자료형과 참조 자료형으로 나누는 이유는 데이터 관리방식이 다르기 때문이다.

    ●　기본 자료형의 데이터 관리: 깊은복사
        // 코드
        let num = 10;
        let copyNum = num;
        num = 20; // 변수 num을 재할당
        console.log(num); // 20
        console.log(copyNum); // 10

        변수 num만 값이 변경되고 copyNum은 변경되지 않는다 두 데이터는 연동되어있지 않다.
        이렇게 복사한 값을 재할당 할때 한쪽 데이터가 변경되어도 서로 영향을 미치지 않게 복사되는 것을 '깊은 복사(deep copy)' 라고 한다

    ●　참조 자료형의 데이터 관리: 얕은 복사
        기본자료형과 다르게 객체와 같은 참조 자료형은 변수 공간에 데이터가 할당되는 것이 아니고 데이터가 위치하고 있는 메모리의 주소값만 할당된다.
        이걸 자바스크립트에서는 '참조한다' 라고 한다.
        데이터의 재할당은 불가능 하지만 객체에 속성을 추가하거나 값을 변경하는 건가능하다
        변수의 입장에서 데이터를 재할당하는 것이 아니기 때문
        주소값은 그대로이고 주소값이 참조하는 원본 객체 데이터만 변경되기 때문에 기존데이터를 변경하거나 새로운 속성을 추가할 수 있다.
            //코드
            const person = {
                name:"Junhyung"
            };
            const copyPerson = person; // 변수 person에 할당된 객체를 변수 copyPerson에 복사
            person.name = "Park"; // 변수 person에 할당된 객체의 값을 변경
            console.log(person.name); // Park
            console.log(copyPerson.name); // Park
        분명 변수 person에 할당한 객체의 속성값을 변경했는데 변수 copyPerson에 복사된 객체의 속성값까지 변경된다.
        이는 객체가 변수에 할당될 때 변수는 주소 값만 가지고 있어서 복사할때도 주소값만 복사하기 때문
        그래서 두 변수는 같은 주소값을 가지게 되고 바라보는 원본 데이터의 위치도 같다
        그러므로 변수 person의 데이터를 변경하면 같은 주소를 바라보는 copyPerson의 데이터까지 변경된다
        이렇게 데이터를 복사했을때 한쪽 데이터가 변경되면 다른쪽 데이터도 변경되어 서로 영향을 받는것을 '얕은복사(shallow copy)' 라고 한다.

11.3 표준 내장 객체 사용하기
    자바 스크립트에 기본으로 내장된 객체를 '표준내장객체 (standard built-in-object)' 라고 한다.
    표준내장객체에는 문자열을 다루는 String 배열자료형을 다루는 Array가 있다. 그리고 날짜와 시간을 다루는 Date 객체와 수학 수식을 다루는 Math등이 있다.

11.3.1 문자열을 다루는 String 객체

    length 속성 : 문자열의 길이를 알 수 있어서 최소글자수나 최대 글자수를 확인해야할때에 유용하다
        //코드
        const pw = "123";
        if(pw.length < 4){
            console.log("비밀번호는 최소 4자리 이상입력해라");
        }

    includes() 메서드 : 특정문자열이 포함되어 있는지 확인
        //코드
        const email = "test!naver.com";
        if (email.includes('@') === false){
            console.log("올바른 이메일 형식이 아닙니다.");
        }

    indexOf() 메서드 : 특정문자열이 포함되어있는지 확인, 특정 문자열과 일치하는 첫 번째 문자의 인덱스를 반환하는데 찾지못하면 -1을 반환
        //코드
        const email = "test!naver.com";
        if(email.indexOf("@") === -1){
            console.log("올바른 이메일 형식이 아닙니다.");
        }

11.3.2 배열을 다루는 Array 객체
    length 속성 : 배열의 요소개수 즉 길이를 구할수 있다. 배열의 길이를 이용한 반복문 처리가 가능하다
        //코드
        const arr = [10, 20, 30];
        for(let i = 0; i < arr.length; i++){
            console.log(arr[i]);
        }

    파괴적 메서드와 비파괴적 메서드
        파괴적 메서드 :  메서드를 사용했을 때 원본데이터를 변경
        비파괴적 메서드 : 원본을 변경하지 않는 메서드
    배열에 데이터를 추가하거나 추출하는 기능의 push() pop() unshift() shift() 는 파괴적 메서드이다. 그래서 메서드를 사용하면 원본데이터가 변경된다.
        //코드
        const arr = [10, 20, 30, 40];

        arr.push(50); // 배열 맨뒤에 50 추가
            console.log(arr); // [ 10, 20, 30, 40, 50 ]

        arr.pop(); // 배열 맨 뒤에서 요소 추출
            console.log(arr); // [ 10, 20, 30, 40 ]

        arr.unshift(0); // 배열 맨 앞에 0 추가
            console.log(arr); // [ 0, 10, 20, 30, 40 ]

        arr.shift(); // 배열 맨 앞에서 요소 추출
            console.log(arr); // [ 10, 20, 30, 40 ]

    비파괴적 메서드인 forEach() 는 배열 요소를 순회하면서 콜백함수은 function(v)를 호출해 접근한 요소의 값을 출력한다.
    마치 반복문으로 배열요소에 접근하는 것과 비슷한 기능을 제공한다
        //코드
        arr2.forEach(function (v){
            console.log(v); // 10 20 30 40
        })
        console.log(arr2); // [ 10, 20, 30, 40 ]
    비파괴적 메서드는 원본을 변경하지 않기 때문에 arr 변수에 할당된 배열 데이터는 그대로 보존된다.

11.3.3 날짜와 시간을 다루는 Date 객체

    ●　인스턴스 만들기
        Date 객체를 사용하려면 먼저 Date 객체를 호출해 날짜와 시간 데이터를 생성해야 한다.
            //코드
            const date = new Date();
        new 키워드로 Date 객체를 호출하면 현재 날짜와 시간정보를 기반으로 날짜와 시간 데이터가 생성된다.

        이때 생성되는 데이터를 자바스크립트에서 '인스턴스'라고 한다. 따라서 date변수에 할당된 데이터는 Date객체의 인스턴스이다.
            //코드
            const date1 = new Date(2022, 11, 25);
            const date2 = new Date(2022, 11, 25, 18, 30, 50);

        문자열로 원하는 날짜와 시간 데이터를 생성하는 방법
            //코드
            const date1 = new Date("2024-11-15");
            const date2 = new Date("2024/11/15/18:30:50");

    ●　메서드로 날짜와 시간 정보 가져와서 설정하기
        Date 객체에서 get으로 시작하는 메서드는 날짜와 시간 정보를 가져오고
        set으로 시작하는 메서드는 날짜와 시간 정보를 설정한다
            //코드
            const date = new Date("2022, 11, 25, 18, 30, 50");
            const dateFormat = `${date.getFullYear()}-${date.getMonth()+1}-${date.getDate()}
                                ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;
            console.log(dateFormat); // 2022-12-25 18:30:50

    ●　날짜 간격 계산하기
        getTime() 메서드는 1970년 1월 1일 12:00 이후의 시간을 밀리초 단위로 반환한다
            //코드
            const date2 = new Date().getTime();
            console.log(date2); //1731674932041
        이러한 반환 결과를 활용하면 두 날짜 사이의 간격을 구할 수 있다.
            //코드
            const date1 = new Date('2022-12-23');
            const date2 = new Date('2022-12-25');
            const dateDiff = date2.getTime() - date1.getTime();
            const interval = dateDiff / (20 * 60 * 60 * 1000);
            console.log(`두 날짜의 차이는 ${interval}일 입니다.`); //두 날짜의 차이는 2.4일 입니다.
        먼저 Date 객체로 날짜 데이터인 인스턴스를 생성한다. 두 인스턴스에 getTime() 메서드를 사용하면 날짜가 밀리초단위로 반환되는데
        더 큰 숫자인 미래 날짜에서 더 작은 숫자인 과거 날짜를 뺀다 그러면 그 두 날짜 사이의 간격을 밀리초로 구할 수 있다.
        이렇게 구한 밀리초를 24(시간) * 60(분) * 60(초) * 1000(밀리초) 로 나누면 두 날짜 사이의 간격을 일수로 환산 가능하다

11.3.4 수학 연산을 다루는 Math 객체
    Math 객체는 new 키워드 없이 Math 객체에 바로 메서드를 사용한다.
    예를들어 다음과 같은 실수 데이터에 floor() ceil() round() 메서드를 사용하면 손쉽게 내림 올림 반올림을 처리가능하다
        //코드
        let floatNum = 10.52;
        Math.floor(floatNum); // 10
        Math.ceil(floatNum); //11
        Math.round(floatNum); //11

    ●　난수 구하기
        Math 객체의 random() 메서드는 0이상 1미만의 난수를 반환한다. 따라서 같은 코드라도 실행할때마다 값이 달라진다.
            //코드
            const random = Math.random();
            console.log(random); // 실행할때마다 달라짐

        그 이상의 난수를 구하고 싶을땐 주어진 숫자를 내림해서 정수를 반환하는 floor() 메서드를 추가해 난수의 범위를 늘릴수 있다.
        예를들어 난수 범위를 0 이상 20 이하의 정수로 바꾸고 싶을때 0.999라는 수가 나왔을때 여기에 20을 곱하면 19.98이된다.
        여기에 다시 floor() 메서드를 사용하면 19가 나온다.
            //코드
            function getMaxRandom(max){
                return Math.floor(Math.random() * max + 1);
            }
            const maxRandom = getMaxRandom(20);
            console.log(maxRandom); // 0 이상 20 이하의 무작위의 정수

        난수의 최소값구하기
            //코드
            function getMinMaxRandom(min, max){
                return Math.floor(Math.random() * (max-min)) + 1 + min; // 20을 제외하고 싶으면 + 1 삭제
            }
            const maxRandom = getMinMaxRandom(10, 20);
            console.log(maxRandom); //10 이상 20 이하의 무작위의 정수

24.11.16 (토)
11.4 브라우저 객체 모델 사용하기
    브라우저 객체 모델 : 자바스크립트 언어사양에 포함되지 않고 웹브라우저에서 제공하는 객체

11.4.1 window 객체의 속성과 메서드 (필요할때마다 검색하기)

11.4.2 window 객체의 기본 속성 사용하기 (이것도 검색해보기)

11.4.3 웹 브라우저에서 새 창 제어하기
    window객체의 open() 메서드는 웹 브라우저에서 새로운 창을 여는데 사용한다.
    open() 메서드는 매개변수로 창의 경로, 이름, 속성을 전달받는다.
        //형식
        window.open(경로, 이름, 속성);

    button 태그를 클릭했을 때 popup.html 파일이 새 창에서 열리게 하고 싶다면 open() 메서드를 다음과 같이 사용한다
        //코드
        <body>
            <button onclick="popup()">팝업</button>
            <script>
                function popup(){
                    window.open('popup.html','팝업','width=200, height=100');
                }
            </script>
        </body>
    코드를 실행해 보면 팝업버튼이 보인다. 버튼을 클릭하면 popup() 함수가 호출되어 window 객체의 open() 메서드가 실행된다.
    open() 메서드의 첫번째 매개변수로 전달된 popup.html은 새창에서 열릴 파일의 경로를 나타낸다.
    즉 popup.html 파일을 새로운 웹 브라우저 창에서 열라는 의미
    두번째 매개변수로 전달된 팝업은 새창의 이름을 '팝업'이라고 지정하겠다는 뜻
    단 여기서의 이름은 웹브라우저 탭에 보이는 이름이 아니고 open() 메서드로 열리는 창을 내부적으로 구분하는 용도로 사용하는 이름.
    요컨데 open() 메서드는 기본으로 이름이 같은 창은 1개만 열기 때문에 팝업버튼을 여러 번 눌러도 1개의 창만 열린다.
    두번재 매개변수를 빈 문자열('')로 설정하고 팝업 버튼을 눌러보면 그 차이점을 확실히 알 수 있다.
    세번째 매개변수는 새 창의 속성을 지정하는 값으로 이 코드에서는 새 창의 너비를 200px, 높이를 100px로 지정한다.
    코드를 실행하고 팝업 버튼을 누르면 새로운 웹 브라우저 창이 가로 200px 세로 100px 크기로 열린다.
    이렇게 열린창은 window 객체의 close() 메서드로 닫을 수 있다. close() 메서드는 보통 open() 메서드로 열린 새로운 창을 닫는 용도로 사용
        //코드
        <button onClick="window.close()">팝업 닫기</button>

11.4.4 웹 브라우저의 스크롤 이동하기
    window 객체의 scrollTo() 메서드는 웹 브라우저의 스크롤 위치를 특정 좌표로 이동하게 한다.
    그리고 scrollBy() 메서드는 웹 브라우저의 스크롤을 현재 위치에서 상대적인 위치로 이동하게 한다.
    두 메서드는 기본으로 매개변수에 x좌표와 y좌표를 전달받는다.
        //형식
        window.scrollTo(x좌표, y좌표);
        window.scrollBy(x좌표, y좌표);

    예를 들어 다음과 같이 작성하면 scrollTo() 메서드를 몇번을 호출하더라도 가로는 100px, 세로는 200px의 위치로 스크롤이 이동한다
    그러나 scrollTo() 메서드 대신에 scrollBy() 메서드를 사용하면 웹 브라우저 스크롤의 현재위치에서 상대적인 위치로 움직이기 때문에
    메서드를 호출할 때마다 웹 브라우저 스크롤이 가로 방향으로 100px 세로 방향으로 200px씩 계속 이동한다.
        //코드
        window.scrollTo(100, 200);
        window.scrollBy(100, 200);
    또는 다음 처럼 객체 리터럴을 전달 받을 수도 있다.
        //코드
        window.scrollTo({left:100, top:200});
        window.scrollBy({left:100, top:200});
    scrollTo() 메서드나 scrollBy() 메서드의 매개변수에 객체 리터럴을 전달할때 behavior 속성을 전달할 수 있다.
    behavior 속성값을 smooth로 하면 웹 브라우저 스크롤이 해당위치로 마우스 휠을 굴리듯이 부드럽게 이동한다.
        //코드
        window.scrollTo({top:4000, behavior:'smooth'});
        window.scrollBy({top:600, behavior:'smooth'});

------------------------------------------------------------------------------------------------------------------------------
마무리
    1. 객체
        객체는 키와 값으로 구성된 속성들의 집합을 의미하는 자료형

    2. 객체 접근 방법
        객체는 대괄호 연산자나 마침표 연산자로 접근할 수 있다
            //형식
            객체["키"] = 값;
            객체.키 = 값;

    3. 객체의 속성 추가 또는 삭제하기
        객체의 속성에 접근해서 새로운 값을 할당할 때 존재하지 않는 키라면 새로운 속성이 추가된다. 그리고 delete 키워드로 속성에 접근하면 기존속성이 삭제된다.
            //형식
            delete 객체.키;

    4. 객체의 특성
        객체는 기본 자료형과는 다르게 할당된 변수가 값을 직접가지고 있는 것이 아니라 데이터가 위치한 주소 값을 가지고 있다.
        따라서 같은 주소 값을 공유하는 변수는 주소 값의 데이터가 변경되면 동시에 값이 변경된다. 이런현상을 얕은 복사라고 한다.

    5. 표준 내장 객체
        자바스크립트에 이미 정의 된 객체를 표준 내장 객체라고 한다.
            종류                          설명
            String      기본 자료형 중 문자열과 관련 있는 속성과 메서드가 정의된 객체
            Array       기본 자료형 중 배열과 관련있는 속성과 메서드가 정의된 객체
            Date        날짜 및 시간과 관련 있는 속성과 메서드가 정의된 객체
            Math        수학 연산과 관련있는 속성과 메서드가 정의된 객체

    6. 브라우저 객체 모델
        웹 브라우저에서 제공하는 객체로 브라우저를 제어할 수 있는 여러 기능이 포함되어 있다.
            종류                          설명
            window      웹 브라우저가 열릴때마다 생성되는 최상위 관리 객체
            document    웹 브라우저에 표시되는 html 문서정보가 포함된 객체
            location    웹 브라우저에 현재 표시된 페이지에 대한 URL 정보가 포함된 객체
            history     웹 브라우저에 저장된 방문 기록이 포함된 객체
            navigator   웹 브라우저 정보가 포함된 객체
            screen      웹 브라우저의 화면정보가 포함된 객체
------------------------------------------------------------------------------------------------------------------------------

12장 문서 객체 모델과 이벤트 다루기

12.1 문서 객체 모델 이해하기
    웹 브라우저는 HTML 문서의 구성 요소를 모두 객체로 인식한다. 웹 브라우저는 문서 객체모델을 생성할 수 있다.
    문서 객체 모델이란 웹 브라우저에 표시되는 HTML 문서 구조를 객체화한 모델 구조를 의미한다.
    웹 브라우저는 생성한 문서 객체 모델을 통해 HTML 문서의 구성 요소를 객체로 인식할 수 있다.
    그리고 자바스크립트도 웹 브라우저의 문서 객체 모델을 조작해 웹 브라우저에 표시되는 HTML 문서 구조를 변경하거나 새로운 구성 요소를 추가하는 등의 작업을
    할 수 있다.

12.1.1 문서 객체 모델이 생성되는 방식
    문서 객체 모델은 웹 브라우저가 HTML 문서를 해석하고 해석한 HTML 문서 구조를 객체로 변환하는 방식으로 생성된다.
    그리고 생성한 문서 객체모델을 웹 브라우저에 표시한다. 따라서 웹 브라우저에서 표시되는 HTML 문서는 내부적으로 문서 객체모델을 해석해서 보이게 된다.
    문서 객체 모델은 트리구조를 가진다 그래서 이를 가르켜 DOM 트리 라고 한다.
        ex) #document
             ├── DOCTYPE
             └── html
                  ├── head
                  │     ├── meta (charset="UTF-8")
                  │     └── title
                  │           └── "Document"
                  └── body
                        ├── h1
                        │     └── "header"
                        └── a (href="#")
                              └── "link"

    DOM 트리는 document 객체 하위에 HTML 태그 요소 속성 텍스트 주석등이 트리 형태로 구성되는데 이를 각각 노드라고 한다.
    그리고 DOM트리 가장 꼭대기에 있는 노드를 '루트 노드'라고 한다. document는 노드가 아니라 객체이므로 여기서는 html이 루트 노드가 된다
    그리고 각 노드는 부모 자식 형제 관계가 형성된다. 예를 들어 html 노트는 head노드와 body노드의 부모 노드이다
    head 노드와 body 노드는 같은 레벨에 있으며 형제 노드이고 html 노드의 자식 노드이다.

12.1.2 노드 타입 살펴보기
    모든 노드가 똑같은 타입으로 생성되는 건 아니다
    HTML 구성요소에 따라 노드도 서로 다른 타입이 된다.
    5가지 노드 타입이 있다고 알고 있으면 된다.

        타입                                          설명
        문서 노드(Node.DOCUMENT_NODE)        최상위 document 객체의 노드 타입
        요소 노드(Node.ELEMENT_NODE)         h1, p태그와 같은 요소의 노드 타입
        속성 노드(Node.ATTRIBUTE_NODE)       href, src와 같은 속성의 노드 타입
        텍스트 노드(Node.TEXT_NODE)          텍스트에 해당하는 노드 타입
        주석 노드(Node.COMMENT_NODE)         주석에 해당하는 노드 타입
    CSS와 관련있는 노드 타입은 없다.

12.2 노드 선택하기
    자바스크립트로 웹 브라우저에 표시되는 HTML 문서를 조작하려면 문서 객체 모델을 조작해야한다.
    문서 객체 모델은 window 객체의 document 객체를 사용해 조작할 수 있다.
    그래서 자바스크립트도 HTML 문서를 조작할 때 가장 먼저 할 일은 document 객체로 조작하려고 하는 문서 객체 모델의 노드를 선택하는 것이다.
    노드는 문서 노드부터 주석 노드까지 여러타입이 있지만 자바스크립트는 주로 요소 노드를 선택해 조작한다.

12.2.1 속성으로 노드 선택하기
    document 객체는 트리를 탐색하면서 원하는 노드를 선택할 수 있는 속성을 제공한다.
    속성은 크게 노드의 타입을 구분하지 않고 모든 노드를 탐색할 수 있는 속성과 요소 노드만 탐색할 수 있는 속성으로 구별이 가능하다.

    구분                    속성                              설명
    모든 노드탐색          parentNode                  부모 노드를 반환한다
                        childNodes                  모든 자식 노드를 반환한다
                        firstChild                  첫번째 자식 노드를 반환한다
                        lastChild                   마지막 자식 노드를 반환한다
                        previousSibling             이전 형제 노드를 반환한다
                        nextSibling                 다음 형제 노드를 반환한다

    요소 노드탐색          parentElement               모든 요소 노드를 반환한다
                        children                    자식 요소 노드를 반환한다
                        firstElementChild           첫번째 자식 요소 노드를 반환한다
                        lastElementChild            마지막 자식 요소 노드를 반환한다
                        previousElementSibling      이전 요소 노드를 반환한다
                        nextElementSibling          다음 요소 노드를 반환한다

    예를들어 위의 문서 객체모델을 기준으로 document 객체로 접근할 수 있는 html 노드로 이동하고 싶다면 firstChild 속성을 사용하고
    첫번째 자식 요소 노드로 이동하고 싶다면 firstElementChild 속성을 사용하면 된다
        //코드
        document.firstChild; // <DOCTYPE html>
        document.firstElementChild; // <html>

    노드 탐색 속성은 다음과 같이 연속으로 사용할 수 있다.
        //코드
        document.childNodes[1].firstElementChild.firstElementChild.nextElementSibling;

12.2.2 메서드로 노드 선택하기
    노드 탐색 속성으로 노드를 선택하는 방법은 노드의 타입을 가리지 않고 모든 노드를 이동하며 선택할 수 있다는 장점이 있다.
    하지만 DOM 트리가 복잡할수록 원하는 노드를 찾아가기 어렵다는 단점도 있다.
    그래서 일반적으로 요소 노드를 바로 선택할 수 있는 메서드를 이용한 노드 선택 방법과 적절하게 조합해서 사용한다

        ●　속성값과 태그명 사용하기 - get 메서드
            document 객체에는 노드를 선택할 수 있는 여러 메서드가 포함되어 있다.

            메서드 형식                                                       설명
            getElementById(<id 속성값>)                     id 속성값과 일치하는 요소 노드를 1개만 선택한다
            getElementByClassName(<Class 속성값>)           class 속성값과 일치하는 요소 노드를 모드 선택한다
            getElementByTagName(<Tag명>)                   태그명과 일치하는 요소 노드를 모두 선택한다.

            각 메서드는 매개변수로 class 속성값 id 속성값 HTML 태그명을 전달받아 노드를 선택한다.
            그럼 각 메서드로 요소노드를 어떻게 선택하는지 예제 코드로 보자
                //코드
                <script>
                        // id 속성값이 title인 요소 노드 1개 선택하기
                        const el = document.getElementById("title");
                        console.log(el);

                        //class 속성값이 text인 요소 노드 모두 선택하기
                        const classEl = document.getElementsByClassName("text");
                        console.log(classEl);

                        // p 태그에 해당하는 요소 노드 모두 선택하기
                        const tagEls = document.getElementsByName("p");
                        console.log(tagEls);
                    </script>
            단일 요소 노드를 선택하는 getElementById() 메서드와 나머지 메서드의 차이점이 보인다
            getElementById() 메서드로 선택하는 요소 노드는 무조건 1개이기 때문에 해당하는 요소 하나만을 보여주지만 다른 두 메서드는
            HTMLCollection 객체로 여러 요소를 한꺼번에 선택한다
            여기서 HTMLCollection 객체는 유사 배열이라 다음 코드처럼 배열의 인덱스로 요소에 하나씩 접근할 수 있다.
                //코드
                    //class 속성값이 text인 요소 노드 하나씩 보기
                    const classEl = document.getElementsByClassName("text");
                    console.log(classEl[0]);
                    console.log(classEl[1]);

                    // p 태그에 해당하는 요소 노드 하나씩 보기
                    const tagEls = document.getElementsByName("p");
                    console.log(tagEls[0]);
                    console.log(tagEls[1]);
            유사배열
                여러개의 노드를 선택하는 document 객체의 속성이나 메서드를 사용하다보면 선택된 노드들이 HTMLCollection 객체나
                NodeList 객체등에 담겨 반환되는 것을 볼 수 있다. 출력형태를 보면 배열처럼 보이지만 배열자료형에는 없는 여러 객체속성을 가진다.
                그래서 자바스크립트에선 이런 객체를 배열과 비슷하게 보인다고 해서 '유사배열' 이라고 한다.
                여기서는 객체 형태이지만 배열처럼 인덱스로 각각의 요소에 접근할 수 있다는 정도만 알면 된다.

        ●　CSS 선택자 사용하 - query 메서드
            document 객체의 메서드 중에는 매개변수로 CSS 선택자를 전달받아 노드를 선택하는 메서드도 있다

                메서드 방식                                               설명
                querySelector(<CSS 선택자>)            매개변수로 넘어오는 CSS 선택지에 해당하는 노드를 1개만 선택한다
                querySelectorAll(<CSS 선택자>)         매개변수로 넘어오는 CSS 선택지에 해당하는 노드를 모두 선택한다

            querySelector() 메서드는 요소 노드를 1개만 선택할때 사용하고
            querySelectorAll() 메서드는 노드를 2개 이상 선택할 때 사용한다.
            둘다 매개변수로 CSS 선택자를 전달받으므로 원하는 노드를 선택하기가 쉽다.
                //코드
                <body>
                    <div class="box-1">
                        <p class="text">text1</p>
                        <p class="text">text2</p>
                    </div>
                    <div class="box2">
                        <p class="text">text-3</p>
                        <p class="text">text-4</p>
                    </div>
                </body>
            이런 HTML 문서가 있을때 class 속성값이 box-1인 요소 노드를 선택하려면 querySelector() 메서드를 이용한다면 다음과 같이 한다.
                //코드
                <script>
                        const el = document.querySelector(".box-1");
                </script>
            이번에는 class 속성값이 box-1 인 요소의 하위에 있는 p태그를 가져와 본다. 먼저 class 속성값을 사용하는 getElementsClassName()
            메서드로 다음과 같이 작성할 수 있다.
                //코드
                <script>
                    const elP = document.getElementsByClassName("box-1")[0].children;
                    console.log(elP);
                </script>
            원하는 노드는 선택할 수 있지만 코드가 조금 복잡하다. CSS 선택자를 사용하는 querySelectorAll(<CSS 선택자>) 로 쓰면
                //코드
                <script>
                    const el = document.querySelectorAll(".box-1 .text");
                    console.log(el);
                </script>
            매서드의 매개변수에 CSS 선택자를 전달하니 더 간단하게 원하는 노드를 선택할 수 있다.
            단 여러개의 노드를 선택할 때 getElementsByClassName() 메서드와 getElementsByTagName() 메서드는 HTMLCollection 객체에 담아
            반환했지만 querySelectorAll() 메서드는 NodeList 객체에 담아 반환한다.

                ✳︎　document 객체의 get 매서드보다 query 메서드를 사용하는 것이 낫다.

12.3 노드 조작하기
    document 객체의 속성이나 메서드로 문서 객체 모델의 노드를 선택하고 나면 선택한 노드에 여러 조작을 할 수 있다.
    이 절에서는 가져온 노드를 조작하는 방법을 배워보자

12.3.1 콘텐츠 조작하기
    선택한 노드의 타입이 요소 노드라면 다음 표에 정의된 속성을 사용해 콘텐츠를 조작할 수 있다.
        속성                              설명
        textContent            요소 노드의 모든 텍스트에 접근한다
        innerText              요소 노드의 텍스트 중 웹 브라우저에 표시되는 텍스트에만 접근한다
        innerHTML              요소 노드의 텍스트 중 HTML 태그를 포함한 텍스트에만 접근한다.

            //코드
            <p id="title">Hello, <span style="display: none">Javascript</span></p>
            <!-- 이 코드를 콘텐츠 조작 속성으로 접근했을 때 각 속성이 가져오는 콘텐츠는 다음과 같다 -->
            <script>
               document.getElementById("title").textContent; // Hello, Javascript
               document.getElementById("title").innerText; // Hello,
               document.getElementById("title").innerHTML; // Hello, <span style="display: none">Javascript</span>
            </script>

    콘텐츠 조작 속성은 접근한 노드의 콘텐츠를 가져올 뿐만 아니라 속성에 값을 할당하면 각 노드의 콘텐츠를 바꿀 수도 있다.
        //코드
        <body>
            <p id="textContent"></p>
            <p id="innerText"></p>
            <p id="innerHTML"></p>
            <script>
                document.querySelector("#textContent").textContent = `<strong>textContent</strong> 속성`;
                document.querySelector("#innerText").innerText = `<strong>innerText</strong> 속성`;
                document.querySelector("#innerHTML").innerHTML = `<strong>innerHTML</strong> 속성`;
            </script>
        </body>
        innerHTML 속성에 값을 할당하면 태그로 인식해 노드의 콘텐츠에 적용된다(3번)
        그러나 나머지 속성은 단순히 텍스트로 취급해서 값을 그대로 노드의 콘텐츠에 넣는다.

12.3.2 스타일 조작하기
    선택된 노드의 타입이 요소 노드라면 style 속성으로 요소에 스타일 CSS를 지정할 수 있다.
        //형식
        <노드>.style.<CSS 속성명> = <속성값>;

    예를들어 p 태그의 텍스트 색상을 빨간색으로 변경하고 싶다면 다음과 같이 작성한다
        //코드
        <p id="text">text</p>
        <script>
          const pEl = document.querySelector("p"); //노드 선택하기
          pEl.style.color = "red";
        </script>
    querySelector() 메서드로 스타일을 조작하고 싶은 노드를 선택한다.
    그리고 선택한 노드에 style 속성으로 조작하고 싶은 CSS 속성명을 적고 적용하고 싶은 CSS 속성값을 할당한다.
    주의할점은 CSS 속성중 background-color 속성과 같이 속성명에 대시(-)가 있는 속성은 자바스크립트에서 뺄셈으로 인식한다
    그러므로 backgroundColor 처럼 카멜 표기법으로 변경해서 작성해야 한다
        //코드
        <p id="text">text</p>
        <script>
          const pEl = document.querySelector("p"); //노드 선택하기
          pEl.style.backgroundColor = "#ff0000";
          pEl.style.fontSize = "20px";
          pEl.style.color = "#ffffff";
        </script>

12.3.3 클래스 속성 조작하기
    style 속성으로 스타일을 조작하면 속성을 하나씩 적어야 해서 불편하다
    이때 지정해야하는 스타일이 명확하다면 자바스크립트로 속성을 하나씩 지정하지 않고
    p태그에 class 속성을 추가하고 클래스 선택자로 지정하는 편이 더 깔끔하다.

    자바스크립트로도 class 속성을 조작해 스타일을 적용할 수 있다.
    선택한 요소 노드에 class 속성을 지정할 때는 classList 속성의 add() remove() toggle() 메서드를 사용한다.
        //형식
        <노드>.classList.add("class 속성값"); //추가
        <노드>.classList.remove("class 속성값"); //삭제
        <노드>.classList.toggle("class 속성값"); //추가와 삭제 반복

        //코드
        <style>
            .red-color{
                color:red;
            }
            .fz20{
                font-size: 30px;
            }
        </style>
        </head>
        <body>
            <p id="text">text</p>
            <script>
                const pEl = document.querySelector("#text"); // 노드 선택하기
                pEl.classList.add("red-color");
                pEl.classList.add("fz20");
            </script>
        </body>

    이 코드는 원래 p태그에 id 속성만 있었는데 classList 속성의 add() 메서드로 class 속성값을 추가한다.
    실행결과를 개발자 도구에서 보면 p태그에 class 속성값이 추가되었다. 그래서 콘텐츠에 CSS로 작성한 스타일이 적용되었다

    class 속성을 한 번에 추가할 수도 있다.
        //코드
        pEl.classList.add("red-color","fz20");

    적용된 class 속성값을 삭제하고 싶을땐 classList 속성의 remove()메서드를 사용한다
        //코드
        pEl.classList.remove("red-color","fz20");
    p 태그에 적용된 class 속성값인 red-color, fz20이 삭제되어 기본 스타일로 돌아간다

    마지막으로 toggle() 메서드는 add() 메서드와 remove() 메서드를 반복해서 호출한다.
        //코드
        <script>
            const pEl = document.querySelector("#text"); // 노드 선택

            // 1초마다 toggle()메서드 반복실행
            setInterval(function (){
                pEl.classList.toggle("red-color");
            }, 1000);
        </script>

12.3.4 데이터 속성 조작하기
    data-* 속성은 HTML 문법에서 사용할 수 있는 속성외에 사용자가 원하는 속성을 추가할 수 있게 한 사용자 정의 속성이다.
    data-* 속성은 자바스크립트의 dataset 속성을 사용해 조작할 수 있다.
    dataset 속성은 HTML 문서에서 data-*속성을 가져오거나 지정한다

    data-* 속성이 적용된 HTML 요소 노드를 선택해 data속성값을 출력해보자
        //코드
        <button data-cnt="10">가방 구매</button>
        <button data-cnt="0">신발 구매</button>
        <script>
            const buttonEls = document.querySelectorAll("button");
            buttonEls.forEach((el)=>{
                console.log(el.dataset);
                })
        </script>
    querySelectorAll() 메서드로 button 태그에 해당하는 노드를 한번에 선택
    그리고 forEach() 메서드로 반복해서 각 메서드에 접근한 뒤 dataset 속성으로 data-cnt 속성정보를 가져와 출력한다.

    실행결과를 보면 dataset 속성으로 노드의 data-* 속성에 대한 정보를 가져오고 이 정보가 DOMStringMap 객체에 담겨 반환된다.

    이 중에서 정확하게 data-cnt 의 속성의 값만 가져오고 싶으면 다음처럼 객체 속성에 접근하는 방법을 사용한다.
        //코드
        <script>
            const buttonEls = document.querySelectorAll("button");
            buttonEls.forEach((el)=>{
                console.log(el.dataset.cnt); // 실행결과: 10 0
            })
        </script>

    속성에 값을 할당하면 단순하게 값을 가져오는 것이 아니라 data-cnt 속성의 값을 바꿀 수도 있다
        //코드
        const buttonEls = document.querySelectorAll("button");
        buttonEls.forEach((el)=>{
            el.dataset.cnt = 50;
        })

12.3.5 메서드로 속성 조작하기
    지금까지 document객체의 속성으로 HTML 요소에 접근해 일부 속성을 조작할 수 있었다.
    그런데 다음 메서드를 사용하면 모든 속성을 전체적으로 조작할 수도 있다.
        메서드 형식                                   설명
        <노드>.getAttribute("속성명");           속성값을 가져온다
        <노드>.setAttribute("속성명");           속성값을 설정한다
        <노드>.removeAttribute("속성명");        속성을 삭제한다

        getAttribute() 메서드는 선택된 요소 노드의 속성값을 가져오고 싶을때 사용한다
            //코드
            <a href="https://www.gilbut.co.kr">길벗</a>
            <script>
                const aEl = document.querySelector("a");
                const href = aEl.getAttribute("href");
                console.log(href);
            </script>
        코드를 보면 querySelector() 메서드로 a태그에 해당하는 요소 노드를 선택하고 getAttribute()메서드로 href 속성값을 가져온다.
        그래서 개발자 도구의 콘솔창을 보면 href 속성값이 출력된다.

        속성값을 새로 설정하고 싶을 때는 setAttribute() 메서드를 사용한다.
            //코드
            <script>
                const aEl = document.querySelector("a");
                const href = aEl.getAttribute("href");
                aEl.setAttribute("href","https://www.naver.com/");
                aEl.innerText = "네이버";
            </script>
        코드를 보면 setAttribute()메서드로 href 속성값을 새로 설정한다.
        그리고 a태그의 텍스트틀 바꾸기 위해 innerText 속성도 같이 사용한다.

        이번에는 바꾼 속성값을 적용해 새창으로 열리게 하고 싶다. 그럴땐 target 속성값을 _blank 로 설정하면 된다.
            //코드
            aEl.setAttribute("target","_blank");

        getAttribute() 메서드와 setAttribute() 메서드는 모든 속성의 상위 메서드라서
        classList 속성이나 dataset 속성으로 하는 조작을 전부 할 수 있다.
            //코드
            <a href="https://www.naver.com" data-link="네이버">네이버</a>
            <script>
                const aEl = document.querySelector("a");
                aEl.setAttribute("data-link", "구글");
                aEl.setAttribute("class","red-color");
            </script>

        마지막으로 removeAttribute() 메서드를 사용하면 요소 노드의 속성을 제거할 수 있다.
            //코드
            <a href="https://www.naver.com" data-link="네이버">네이버</a>
            <script>
              const aEl = document.querySelector("a");
              aEl.removeAttribute("class") //class 속성 삭제
            </script>
        코드를 실행하면 a 태그에 class 속성값에 스타일이 적용되어 텍스트가 빨간색이어야 하지만
        removeAttribute() 메서드에 의해 class 속성이 삭제되어서 빨간색으로 보이지 않는다.

        classList 속성과 setAttribute() 메서드
            classList 속성으로 class 속성값을 추가하거나 삭제하면 기존 요소가 가지고 있던 class 속성값을 보존하면서
            추가하거나 삭제한다는 특징이 있다.
            하지만 setAttribute() 메서드는 아예 속성값을 새로 설정하는 것이어서 기존 class 속성값을 보존하지 않는다.
            이는 classList 속성의 remove()메서드와 removeAttribute() 메서드에서도 같다.
            remove() 메서드는 기존 속성을 보존하면서 매개변수로 전달된 속성만 삭제하지만 removeAttribute() 메서드는 속성 자체를 삭제한다.



